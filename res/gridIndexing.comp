#version 430 core

/// Pipeline stage 1 (3).
/// We perform binary search in a parallel manner to determine
/// the index of each Voxel and the number of particles it contains.
/// Each thread is associated with one VoxelId. If a certain Id was
/// not found, the size is set to 0. The value pairs are then written
/// into a lookup-buffer.
///   Input: Particle/Voxel pairs (sorted)
///   Output: Voxel Indices/Element Count pairs

layout (std430, binding = 0) restrict readonly buffer mappingBuf { uint mappings[]; };
layout (std430, binding = 1) restrict writeonly buffer indicesBuf { uint indices[]; };

layout (local_size_x = 128) in;

void found(int index, uint voxelId) {
  uint particleCount = mappings.length() / 2;
  int lower = index;
  int upper = index;
  while (lower > 0 && mappings[(lower-1) * 2 + 1] == voxelId) {
    lower--;
  }
  while (upper < particleCount-1 && mappings[(upper+1) * 2 + 1] == voxelId) {
    upper++;
  }
  indices[voxelId * 2 + 0] = uint(lower);
  indices[voxelId * 2 + 1] = uint((upper - lower) + 1);
}

void main() {
  uint voxelId = gl_GlobalInvocationID.x;
  uint particleCount = mappings.length() / 2;
  uint voxelCount = indices.length() / 2;
  if (voxelId >= voxelCount)
    return;

  int start = 0;
  int end = int(particleCount) - 1;

  while (end >= start) {
    int middle = (start + end) / 2;
    uint val = mappings[middle * 2 + 1];

    if (voxelId == val) {
      found(middle, voxelId);
      return;
    }
    else if (voxelId < val) {
      end = middle - 1;
    }
    else if (voxelId > val) {
      start = middle + 1;
    }
  }

  indices[voxelId * 2 + 0] = 0;
  indices[voxelId * 2 + 1] = 0;
}
