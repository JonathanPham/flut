#version 430 core
#define M_PI 3.14159265358979323846

/// Pipeline stage 2.
/// Particle density is estimated by averaging the surrounding
/// neighbor particles mass. Additionally, the influence of the
/// walls are computed. The total density is stored in a buffer.
///   Input: Density (1), Uniform Grid, Position (1)
///   Output: Density (2)

layout (local_size_x = 128) in;

layout (location = 0) uniform vec3 gridLength;
layout (location = 1) uniform vec3 gridOrigin;
layout (location = 2) uniform uvec3 gridResolution;

layout (location = 3) uniform float mass;
layout (location = 4) uniform float re;

layout (std430, binding = 0) buffer positionBuf1 { float position1[]; };
layout (std430, binding = 1) buffer unsortedBuf { uint unsorted[]; };
layout (std430, binding = 2) buffer sortedBuf { uint sorted[]; };
layout (std430, binding = 3) buffer indicesBuf { uint indices[]; };

layout (std430, binding = 4) buffer densityBuf2 { float density2[]; };


///
uint getVoxelId(uvec3 cellIds) {
  return cellIds.x + gridResolution.x * (cellIds.y + gridResolution.y * cellIds.z);
}

uvec3 getCellIds(uint voxelId) {
  uint zCell = voxelId / (gridResolution.x * gridResolution.y);
  voxelId -= (zCell * gridResolution.x * gridResolution.y);
  uint yCell = voxelId / gridResolution.x;
  uint xCell = voxelId % gridResolution.x;
  return uvec3(xCell, yCell, zCell);
}

///
float weight(float re, float r) {
  return (315 * pow(re * re - r * r, 3)) / (64 * M_PI * pow(re, 9));
}

///
void main() {
  vec3 voxelSize = gridLength / gridResolution;
  uint particleCount = density2.length();
  uint p = gl_GlobalInvocationID.x;
  if (p >= particleCount)
    return;

  uint voxId = unsorted[p * 2 + 1];
  ivec3 cellIds = ivec3(getCellIds(voxId));
  vec3 pos = vec3(position1[p * 3 + 0],
    position1[p * 3 + 1], position1[p * 3 + 2]);

  float d = 0.0;
  ivec3 numCells = ivec3(re / voxelSize + vec3(1.0));
  for (int x = -numCells.x; x <= numCells.x; ++x) {
    for (int y = -numCells.y; y <= numCells.y; ++y) {
      for (int z = -numCells.z; z <= numCells.z; ++z) {

        ivec3 newCellIds = cellIds + ivec3(x, y, z);
        if (newCellIds.x < 0 || newCellIds.x >= gridResolution.x) continue;
        else if (newCellIds.y < 0 || newCellIds.y >= gridResolution.y) continue;
        else if (newCellIds.z < 0 || newCellIds.z >= gridResolution.z) continue;

        uint newVoxId = getVoxelId(uvec3(newCellIds));
        uint newVoxStart = indices[newVoxId * 2 + 0];
        uint newVoxSize = indices[newVoxId * 2 + 1];
        if (newVoxSize == 0)
          continue;

        // Beware that otherParticleId == p is possible and
        // wanted because of density self-contribution.
        // Therefore, the density can never be equal to zero.
        for (uint c = 0; c < newVoxSize; ++c) {
          uint otherParticleId = sorted[(newVoxStart + c) * 2 + 0];
          vec3 otherParticlePos = vec3(position1[otherParticleId * 3 + 0],
            position1[otherParticleId * 3 + 1], position1[otherParticleId * 3 + 2]);

          float posDiff = distance(otherParticlePos, pos);
          if (posDiff >= re)
            continue;

          d += mass * weight(re, posDiff);
        }
      }
    }
  }

  density2[p] = d;
}
