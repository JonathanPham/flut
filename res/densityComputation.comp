#version 430 core

/// Pipeline stage 2.
/// Particle density is estimated by averaging the surrounding
/// neighbor particles mass. Additionally, the influence of the
/// walls are computed. The total density is stored in a buffer.
///   Input: Density (1), Uniform Grid, Position (1), Distance Func, WallWeight Func
///   Output: Density (2)

const float EPS = 0.001;

layout (local_size_x = 128) in;

layout (location = 0) uniform vec3 gridLength;
layout (location = 1) uniform vec3 gridOrigin;
layout (location = 2) uniform uvec3 cellsPerAxis;

layout (std430, binding = 0) buffer positionBuf1 { float position1[]; };
layout (std430, binding = 1) buffer mappingBuf { uint mappings[]; };
layout (std430, binding = 2) buffer indicesBuf { uint indices[]; };
layout (std430, binding = 3) buffer densityBuf1 { float density1[]; };
layout (std430, binding = 4) buffer wallweightBuf { float wallweight[]; };
layout (r32f, binding = 0) uniform readonly image3D distanceBuf;

layout (std430, binding = 5) buffer densityBuf2 { float density2[]; };

uint cellId(float length, float pos) {
  return uint((cellsPerAxis * (1.0 - EPS) * (length - pos)) / length);
}

uint voxelId(uint particleCount, float x, float y, float z) {
  uint xCell = cellId(gridLength.x, x - gridOrigin.x);
  uint yCell = cellId(gridLength.y, y - gridOrigin.y);
  uint zCell = cellId(gridLength.z, z - gridOrigin.z);
  uint vox = xCell + cellsPerAxis.x * (yCell + cellsPerAxis.y * zCell);
  return vox;
}

void main() {
  uint particleCount = mappings.length() / 2;
  // TODO
}
