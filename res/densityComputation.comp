#version 430 core
#define M_PI 3.14159265358979323846

/// Pipeline stage 2.
/// Particle density is estimated by averaging the surrounding
/// neighbor particles mass. Additionally, the influence of the
/// walls are computed. The total density is stored in a buffer.
///   Input: Density (1), Uniform Grid, Position (1), Distance Func, WallWeight Func
///   Output: Density (2)

layout (local_size_x = 128) in;

layout (location = 0) uniform vec3 gridLength;
layout (location = 1) uniform vec3 gridOrigin;
layout (location = 2) uniform uvec3 gridResolution;

layout (std430, binding = 0) buffer positionBuf1 { float position1[]; };
layout (std430, binding = 1) buffer mappingBuf { uint mappings[]; };
layout (std430, binding = 2) buffer indicesBuf { uint indices[]; };
layout (std430, binding = 3) buffer wallweightBuf { float wallweight[]; };

layout (std430, binding = 4) buffer densityBuf2 { float density2[]; };

// TODO: which values?
const float EPS = 0.001;
const float mass = 0.05;
const float re = 0.05;

///
uint cellId(uint cellCount, float length, float pos) {
  return uint((cellCount * (1.0 - EPS) * (length - pos)) / length);
}

uint voxelId(uint particleCount, vec3 pos) {
  vec3 c = pos - gridOrigin;
  uint xCell = cellId(gridResolution.x, gridLength.x, c.x);
  uint yCell = cellId(gridResolution.y, gridLength.y, c.y);
  uint zCell = cellId(gridResolution.z, gridLength.z, c.z);
  uint vox = xCell + gridResolution.x * (yCell + gridResolution.y * zCell);
  return vox;
}

float wallDist(vec3 pos) {
  vec3 global = (pos - gridOrigin - gridLength * 0.5) / gridLength;
  return 0.5 - max(abs(global.x), max(abs(global.y), abs(global.z)));
}

float weight(float re, float r) {
  return (315 * pow(re * re - r * r, 3)) / (64 * M_PI * pow(re, 9));
}

///
void main() {
  vec3 voxelSize = gridLength / gridResolution;
  uint particleCount = mappings.length() / 2;
  uint p = gl_GlobalInvocationID.x;
  if (p >= particleCount)
    return;

  vec3 pos = vec3(position1[p * 6 + 0],
    position1[p * 6 + 1], position1[p * 6 + 2]);
  float d = 0.0;
  for (int x = -1; x <= 1; ++x) {
    for (int y = -1; y <= 1; ++y) {
      for (int z = -1; z <= 1; ++z) {
        vec3 newPos = pos + voxelSize * vec3(x, y, z);
        uint otherVoxelId = voxelId(particleCount, newPos);
        if (otherVoxelId >= gridResolution.x * gridResolution.y * gridResolution.z)
          continue;
        uint otherParticleVoxelId = indices[otherVoxelId * 2 + 0];
        uint otherParticleSize = indices[otherVoxelId * 2 + 1];
        if (otherParticleSize == 0)
          continue;

        for (uint c = 0; c < otherParticleSize; ++c) {
          uint otherParticleId = mappings[otherParticleVoxelId * 2 + c * 2];
          vec3 otherParticlePos = vec3(position1[otherParticleId * 6 + 0],
            position1[otherParticleId * 6 + 1], position1[otherParticleId * 6 + 2]);
          float posDiff = distance(otherParticlePos, pos);

          if (posDiff >= re)
            continue;

          d += mass * weight(re, posDiff);
        }
      }
    }
  }

  float dist = wallDist(pos);
  if (dist <= re) {
    uint i = uint(1024 * (dist / re));
    d += mass * wallweight[i];
  }
  density2[p] = max(0.0000001, d);
}
