#version 430 core

/// Pipeline stage 1 (1).
/// This shader maps a particle to a Voxel of the Uniform Grid.
/// The pairs <Particle, Voxel> are stored in a uint buffer and
/// then sorted in a following shader step.
///   Input: Position (1)
///   Output: Particle/Voxel Mappings

const float EPS = 0.001;

layout (location = 0) uniform vec3 gridLength;
layout (location = 1) uniform vec3 gridOrigin;
layout (location = 2) uniform uvec3 cellsPerAxis;
layout (location = 3) uniform uint particleCount;

layout (local_size_x = 128) in;

layout (std430, binding = 0) buffer positionBuf1 { float position1[]; };
layout (std430, binding = 1) buffer mappingBuf { uint mappings[]; };

uint cellId(float length, float pos) {
  return uint((cellsPerAxis * (1.0 - EPS) * (length - pos)) / length);
}

uint voxelId(uint particleCount, uint particle) {
  float posX = position1[particle * 6 + 0];
  float posY = position1[particle * 6 + 1];
  float posZ = position1[particle * 6 + 2];
  uint xCell = cellId(gridLength.x, posX - gridOrigin.x);
  uint yCell = cellId(gridLength.y, posY - gridOrigin.y);
  uint zCell = cellId(gridLength.z, posZ - gridOrigin.z);
  uint vox = xCell + cellsPerAxis.x * (yCell + cellsPerAxis.y * zCell);
  // Debug Output
  position1[particle * 6 + 3] = float(xCell) / float(cellsPerAxis);
  position1[particle * 6 + 4] = float(yCell) / float(cellsPerAxis);
  position1[particle * 6 + 5] = float(zCell) / float(cellsPerAxis);
  return vox;
}

void main() {
  uint particlesPerGroup = particleCount / gl_NumWorkGroups.x;
  uint startParticle = gl_WorkGroupID.x * particlesPerGroup;
  uint endParticle = startParticle + particlesPerGroup;
  for (uint p = startParticle; p < endParticle; ++p) {
    uint vox = voxelId(particleCount, p);
    mappings[p * 2] = p;
    mappings[p * 2 + 1] = vox;
  }
}
