#version 430 core

/// Pipeline stage 1 (2).
/// Sort Particle/Voxel mappings using the bitonic mergesort
/// algorithm. The pairs are reordered in-place. We need a full
/// order, since the next pipeline step utilizes a binary search.
///   Input: Particle/Voxel pairs (unsorted)
///   Output: Particle/Voxel pairs (sorted)

layout (location = 0) uniform uint size;
layout (location = 1) uniform uint stride;

layout (std430, binding = 0) buffer mappingBuf { uint mappings[]; };

layout (local_size_x = 128) in;

void swap_pairs(uint pos1, uint pos2) {
  uint partiId = mappings[pos1 + 0];
  uint voxelId = mappings[pos1 + 1];
  mappings[pos1 + 0] = mappings[pos2 + 0];
  mappings[pos1 + 1] = mappings[pos2 + 1];
  mappings[pos2 + 0] = partiId;
  mappings[pos2 + 1] = voxelId;
}

void bitonic_sort_step(uint i, uint j, uint k) {
  uint ixj = i^j;
  uint len = mappings.length() / 2;
  if (i >= len || ixj >= len)
    return;

  if (ixj > i) {
    if ((i & k) == 0) {
      if (mappings[i * 2 + 1] > mappings[ixj * 2 + 1]) {
        swap_pairs(i * 2, ixj * 2);
      }
    } else {
      if (mappings[i * 2 + 1] < mappings[ixj * 2 + 1]) {
        swap_pairs(i * 2, ixj * 2);
      }
    }
  }
}

void main() {
  uint index = gl_GlobalInvocationID.x;
  bitonic_sort_step(index, stride, size);
}
