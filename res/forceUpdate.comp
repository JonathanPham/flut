#version 430 core
#define M_PI 3.14159265358979323846
#define FLOAT_MIN 1.175494351e-38

/// Pipeline stage 3.
/// Calculates the new position and velocity using pressure and viscosity,
/// gravity and wall boundary forces. To do that, a neighborhood search is performed.
/// Results vary strongly based on the given physical parameters.
///   Input: Density (2), Uniform Grid, Position (1), Velocity (1)
///   Output: Velocity (2), Position (2)

layout (local_size_x = 128) in;

layout (location = 0) uniform float dt;
layout (location = 1) uniform vec3 gridLength;
layout (location = 2) uniform vec3 gridOrigin;
layout (location = 3) uniform uvec3 gridResolution;
layout (location = 4) uniform vec3 gravity;

layout (location = 5) uniform float k;
layout (location = 6) uniform float mass;
layout (location = 7) uniform float re;
layout (location = 8) uniform float visCoeff;
layout (location = 9) uniform float restPressure;
layout (location = 10) uniform float restDensity;

layout (std430, binding = 0) restrict readonly buffer positionBuf1 { float position1[]; };
layout (std430, binding = 1) restrict readonly buffer unsortedBuf { uint unsorted[]; };
layout (std430, binding = 2) restrict readonly buffer sortedBuf { uint sorted[]; };
layout (std430, binding = 3) restrict readonly buffer indicesBuf { uint indices[]; };
layout (std430, binding = 4) restrict readonly buffer densityBuf2 { float density2[]; };
layout (std430, binding = 5) restrict readonly buffer velocityBuf1 { float velocity1[]; };

layout (std430, binding = 6) restrict writeonly buffer velocityBuf2 { float velocity2[]; };
layout (std430, binding = 7) restrict writeonly buffer positionBuf2 { float position2[]; };


///
uint getVoxelId(uvec3 cellIds) {
  return cellIds.x + gridResolution.x * (cellIds.y + gridResolution.y * cellIds.z);
}

uvec3 getCellIds(uint voxelId) {
  uint zCell = voxelId / (gridResolution.x * gridResolution.y);
  voxelId -= (zCell * gridResolution.x * gridResolution.y);
  uint yCell = voxelId / gridResolution.x;
  uint xCell = voxelId % gridResolution.x;
  return uvec3(xCell, yCell, zCell);
}

///
vec3 bbNormalInward(vec3 pos) {
  vec3 absPos = abs(pos) / gridLength;
  float x = (absPos.x > absPos.y && absPos.x > absPos.z) ? 1.0 : 0.0;
  float y = (absPos.y > absPos.x && absPos.y > absPos.z) ? 1.0 : 0.0;
  float z = (absPos.z > absPos.x && absPos.z > absPos.y) ? 1.0 : 0.0;
  vec3 normal = vec3(pos.x * x, pos.y * y, pos.z * z);

  // Prevent any division by zero through normalize()!
  if (length(normal) == 0.0) {
    vec3 toMiddle = (gridOrigin + gridLength / 2) - pos;
    if (length(toMiddle) == 0.0) {
      return vec3(0.0);
    } else {
      return normalize(toMiddle);
    }
  }
  return normalize(-normal);
}

///
vec3 weightPress(float re, vec3 r) {
  return (45 * pow(re - length(r), 3) * r) /
    max(FLOAT_MIN, (M_PI * pow(re, 6) * length(r)));
}

float weightVis(float re, vec3 r) {
  return (45 * (re - length(r))) / (M_PI * pow(re, 6));
}

///
float pressure(float density) {
  return restPressure + k * (density - restDensity);
}

vec3 pressureForce(float mass, vec3 r, float piDen, float pjDen) {
  float pi = pressure(piDen);
  float pj = pressure(pjDen);
  vec3 wPress = weightPress(re, r);
  return (mass * (pi + pj) * wPress) / (2.0 * pjDen);
}

vec3 viscosityForce(float mass, vec3 r, vec3 piVelo, vec3 pjVelo, float pjDen) {
  float wVis = weightVis(re, r);
  return (mass * (pjVelo - piVelo) * wVis) / (pjDen);
}

///
void main() {
  vec3 voxelSize = gridLength / gridResolution;
  uint particleCount = density2.length();
  uint p = gl_GlobalInvocationID.x;
  if (p >= particleCount)
    return;

  uint voxId = unsorted[p * 2 + 1];
  ivec3 cellIds = ivec3(getCellIds(voxId));

  vec3 piPos = vec3(position1[p * 3 + 0],
    position1[p * 3 + 1], position1[p * 3 + 2]);
  vec3 piVelo = vec3(velocity1[p * 3 + 0],
    velocity1[p * 3 + 1], velocity1[p * 3 + 2]);
  float piDen = density2[p];

  vec3 pressure = vec3(0.0);
  vec3 viscosity = vec3(0.0);
  ivec3 numCells = ivec3(re / voxelSize + vec3(1.0));
  for (int x = -numCells.x; x <= numCells.x; ++x) {
    for (int y = -numCells.y; y <= numCells.y; ++y) {
      for (int z = -numCells.z; z <= numCells.z; ++z) {

        ivec3 newCellIds = cellIds + ivec3(x, y, z);
        if (newCellIds.x < 0 || newCellIds.x >= gridResolution.x) continue;
        else if (newCellIds.y < 0 || newCellIds.y >= gridResolution.y) continue;
        else if (newCellIds.z < 0 || newCellIds.z >= gridResolution.z) continue;

        uint newVoxId = getVoxelId(uvec3(newCellIds));
        uint newVoxStart = indices[newVoxId * 2 + 0];
        uint newVoxSize = indices[newVoxId * 2 + 1];
        if (newVoxSize == 0)
          continue;

        for (uint c = 0; c < newVoxSize; ++c) {
          uint pjId = sorted[(newVoxStart + c) * 2 + 0];
          if (pjId == p)
            continue;

          vec3 pjPos = vec3(position1[pjId * 3 + 0],
            position1[pjId * 3 + 1], position1[pjId * 3 + 2]);

          vec3 r = pjPos - piPos;
          if (length(r) >= re)
            continue;

          // Beware of this special case:
          // pi and pj may have the exact same position.
          // In this case, they would have the same density
          // and the same forces. Consequently, they behave
          // exactly the same way and stick together until the
          // end of the simulation. Obviously, we don't want that.
          // But how to apply something to one particle and
          // something else to the other? We need "randomness" - and
          // the most convenient way to get a different value for
          // each particle is by using the particle id.
          // Of course, this handling is not physically correct.
          if (length(r) == 0.0) {
            float zeroToOne = float(p) / float(particleCount);
            vec3 toMiddle = (gridOrigin + gridLength / 2) - pjPos;
            if (length(toMiddle) == 0.0)
              r = vec3(zeroToOne);
            else
              r = normalize(toMiddle) * zeroToOne * re;
          }

          float pjDen = density2[pjId];
          vec3 pjVelo = vec3(velocity1[pjId * 3 + 0],
            velocity1[pjId * 3 + 1],  velocity1[pjId * 3 + 2]);

          pressure += pressureForce(mass, r, piDen, pjDen);
          viscosity += viscosityForce(mass, r, piVelo, pjVelo, pjDen);
        }
      }
    }
  }

  vec3 force = vec3(0.0);
  force += piDen * (-pressure);
  force += visCoeff * viscosity;

  vec3 acceleration = vec3(0.0);
  acceleration += force / piDen;
  acceleration += gravity;

  vec3 newVelo = piVelo + acceleration * dt;
  vec3 newPos = piPos + newVelo * dt;
  vec3 safeDist = vec3(0.01);
  vec3 boundsL = gridOrigin + safeDist;
  vec3 boundsH = gridOrigin + gridLength - safeDist;

  float wallDamping = 0.5;
  vec3 wallNormal = bbNormalInward(piPos);
  vec3 refl = reflect(newVelo * wallDamping, wallNormal);
  if (newPos.x >= boundsH.x) {
    newVelo.x = refl.x;
    newPos.x = boundsH.x;
  } else if (newPos.x <= boundsL.x) {
    newVelo.x = refl.x;
    newPos.x = boundsL.x;
  }

  if (newPos.y >= boundsH.y) {
    newVelo.y = refl.y;
    newPos.y = boundsH.y;
  } else if (newPos.y <= boundsL.y) {
    newVelo.y = refl.y;
    newPos.y = boundsL.y;
  }

  if (newPos.z >= boundsH.z) {
    newVelo.z = refl.z;
    newPos.z = boundsH.z;
  } else if (newPos.z <= boundsL.z) {
    newVelo.z = refl.z;
    newPos.z = boundsL.z;
  }

  velocity2[p * 3 + 0] = newVelo.x;
  velocity2[p * 3 + 1] = newVelo.y;
  velocity2[p * 3 + 2] = newVelo.z;

  position2[p * 3 + 0] = newPos.x;
  position2[p * 3 + 1] = newPos.y;
  position2[p * 3 + 2] = newPos.z;
}
