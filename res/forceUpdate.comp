#version 430 core
#define M_PI 3.14159265358979323846

/// Pipeline stage 3.
/// Calculates the new position and velocity using pressure and viscosity,
/// gravity and wall boundary forces. To do that, a neighborhood search is performed.
/// Results vary strongly based on the given physical parameters.
///   Input: Density (2), Uniform Grid, Position (1), Velocity (1), Distance Func
///   Output: Velocity (2)

const float EPS = 0.001;

layout (local_size_x = 128) in;

layout (location = 0) uniform float dt;
layout (location = 1) uniform vec3 gridLength;
layout (location = 2) uniform vec3 gridOrigin;
layout (location = 3) uniform uvec3 gridResolution;
layout (location = 4) uniform vec3 gravity;

layout (location = 5) uniform float k;
layout (location = 6) uniform float mass;
layout (location = 7) uniform float re;
layout (location = 8) uniform float visCoeff;
layout (location = 9) uniform float restPressure;
layout (location = 10) uniform float restDensity;

layout (std430, binding = 0) buffer positionBuf1 { float position1[]; };
layout (std430, binding = 1) buffer mappingBuf { uint mappings[]; };
layout (std430, binding = 2) buffer indicesBuf { uint indices[]; };
layout (std430, binding = 3) buffer densityBuf2 { float density2[]; };
layout (std430, binding = 4) buffer velocityBuf1 { float velocity1[]; };

layout (std430, binding = 5) buffer velocityBuf2 { float velocity2[]; };
layout (std430, binding = 6) buffer positionBuf2 { float position2[]; };


///
uint cellId(uint cellCount, float length, float pos) {
  return uint((cellCount * (1.0 - EPS) * (length - pos)) / length);
}

uint voxelId(uint particleCount, vec3 pos) {
  vec3 c = pos - gridOrigin;
  if (c.x < 0.0 || c.x > gridLength.x || c.y < 0.0 || c.y > gridLength.y || c.z < 0.0 || c.z > gridLength.z)
    return gridResolution.x * gridResolution.y * gridResolution.z;
  uint xCell = cellId(gridResolution.x, gridLength.x, c.x);
  uint yCell = cellId(gridResolution.y, gridLength.y, c.y);
  uint zCell = cellId(gridResolution.z, gridLength.z, c.z);
  uint vox = xCell + gridResolution.x * (yCell + gridResolution.y * zCell);
  return vox;
}

///
vec3 bbNormal(vec3 pos) {
  vec3 absPos = abs(pos) / gridLength;
  float x = (absPos.x > absPos.y && absPos.x > absPos.z) ? 1.0 : 0.0;
  float y = (absPos.y > absPos.x && absPos.y > absPos.z) ? 1.0 : 0.0;
  float z = (absPos.z > absPos.x && absPos.z > absPos.y) ? 1.0 : 0.0;
  if (x == 0.0 && y == 0.0 && z == 0.0)
    return normalize(pos);
  return normalize(vec3(pos.x * x, pos.y * y, pos.z * z));
}

///
vec3 weightPress(float re, vec3 r) {
  return (45 * pow(re - length(r), 3) * r) / (M_PI * pow(re, 6) * length(r));
}

float weightVis(float re, vec3 r) {
  return (re - length(r)) / (M_PI * pow(re, 6));
}

///
float pressure(float density) {
  return restPressure + k * (density - restDensity);
}

vec3 wallForce(float mass, vec3 pos, float dt) {
  vec3 centered = (pos - gridOrigin - gridLength / 2);
  vec3 wallDist3d = gridLength / 2 - abs(centered);
  float wallDist = min(wallDist3d.x, min(wallDist3d.y, wallDist3d.z));
  if (wallDist >= re)
    return vec3(0.0);
  vec3 wallNormal = -1.0 * bbNormal(centered);
  return (mass * (re - wallDist) * wallNormal) / (dt * dt);
}

vec3 pressureForce(float mass, vec3 r, float piDen, float pjDen) {
  if (length(r) <= 0.0 || pjDen <= 0.000001)
    return vec3(0.0);
  float pi = pressure(piDen);
  float pj = pressure(pjDen);
  vec3 wPress = weightPress(re, r);
  return -1.0 * (mass * (pi + pj) * wPress) / (2 * pjDen);
}

vec3 viscosityForce(float mass, vec3 r, vec3 piVelo, vec3 pjVelo, float pjDen) {
  if (length(r) <= 0.0 || pjDen <= 0.000001)
    return vec3(0.0);
  float wVis = weightVis(re, r);
  return (mass * (pjVelo - piVelo) * wVis) / (pjDen);
}

///
void main() {
  vec3 voxelSize = gridLength / gridResolution;
  uint particleCount = mappings.length() / 2;
  uint p = gl_GlobalInvocationID.x;
  if (p >= particleCount)
    return;

  vec3 pos = vec3(position1[p * 3 + 0], position1[p * 3 + 1], position1[p * 3 + 2]);
  vec3 oldVelocity = vec3(velocity1[p * 3 + 0], velocity1[p * 3 + 1], velocity1[p * 3 + 2]);
  uint vId = voxelId(particleCount, pos);
  float piDen = density2[p];
  if (piDen <= 0.0)
    return;
  vec3 piVelo = vec3(velocity1[p * 3 + 0], velocity1[p * 3 + 1], velocity1[p * 3 + 2]);

  vec3 pressure = vec3(0.0);
  vec3 viscosity = vec3(0.0);
  ivec3 numCells = ivec3(ceil(re / voxelSize));
  for (int x = -numCells.x; x <= numCells.x; ++x) {
    for (int y = -numCells.y; y <= numCells.y; ++y) {
      for (int z = -numCells.z; z <= numCells.z; ++z) {
        vec3 newPos = pos + voxelSize * vec3(x, y, z);
        uint otherVoxelId = voxelId(particleCount, newPos);
        if (otherVoxelId >= gridResolution.x * gridResolution.y * gridResolution.z)
          continue;
        uint otherParticleIndex = indices[otherVoxelId * 2 + 0];
        if (otherParticleIndex == p)
          continue;
        uint otherParticleSize = indices[otherVoxelId * 2 + 1];
        if (otherParticleSize == 0)
          continue;

        for (uint c = 0; c < otherParticleSize; ++c) {
          uint pjId = mappings[otherParticleIndex * 2 + c * 2];
          vec3 pjPos = vec3(position1[pjId * 3 + 0], position1[pjId * 3 + 1],
            position1[pjId * 3 + 2]);

          vec3 r = pjPos - pos;
          if (length(r) >= re)
            continue;

          float pjDen = density2[pjId];
          if (pjDen <= 0.0)
            return;
          vec3 pjVelo = vec3(velocity1[pjId * 3 + 0], velocity1[pjId * 3 + 1],
            velocity1[pjId * 3 + 2]);

          pressure += pressureForce(mass, r, piDen, pjDen);
          viscosity += viscosityForce(mass, r, piVelo, pjVelo, pjDen);
        }
      }
    }
  }

  vec3 acceleration = vec3(0.0);
  acceleration += -1.0 * (1.0 / piDen) * pressure;
  acceleration += visCoeff * viscosity;
  acceleration += wallForce(mass, pos, dt);
  acceleration += gravity / mass; // (?)

  vec3 newVelo = oldVelocity + acceleration * dt;
  velocity2[p * 3 + 0] = newVelo.x;
  velocity2[p * 3 + 1] = newVelo.y;
  velocity2[p * 3 + 2] = newVelo.z;

  vec3 newPos = pos + newVelo * dt;
  vec3 boundsL = gridOrigin;
  vec3 boundsH = boundsL + gridLength;
  position2[p * 3 + 0] = max(boundsL.x, min(newPos.x, boundsH.x));
  position2[p * 3 + 1] = max(boundsL.y, min(newPos.y, boundsH.y));
  position2[p * 3 + 2] = max(boundsL.z, min(newPos.z, boundsH.z));
}
