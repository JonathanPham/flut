#version 430 core
#define M_PI 3.14159265358979323846
#define k 1.0

/// Pipeline stage 3.
/// Calculates the new velocity using pressure and viscosity
/// forces from other particles and the wall boundary.
///   Input: Density (2), Uniform Grid, Position (1), Velocity (1), Distance Func
///   Output: Velocity (2)

layout (local_size_x = 128) in;

layout (location = 0) uniform float dt;
layout (location = 1) uniform vec3 gridLength;
layout (location = 2) uniform vec3 gridOrigin;
layout (location = 3) uniform uvec3 cellsPerAxis;
layout (location = 4) uniform vec3 gravity;

layout (std430, binding = 0) buffer positionBuf1 { float position1[]; };
layout (std430, binding = 1) buffer mappingBuf { uint mappings[]; };
layout (std430, binding = 2) buffer indicesBuf { uint indices[]; };
layout (std430, binding = 3) buffer densityBuf2 { float density2[]; };
layout (std430, binding = 4) buffer velocityBuf1 { float velocity1[]; };
layout (r32f, binding = 0) uniform readonly image3D distanceBuf;

layout (std430, binding = 5) buffer velocityBuf2 { float velocity2[]; };

const float EPS = 0.001;
const float mass = 1.0;
const float re = 0.05;
const float visCoeff = 1.0;
const float restDist = 0.001;

///
uint cellId(uint cellCount, float length, float pos) {
  return uint((cellCount * (1.0 - EPS) * (length - pos)) / length);
}

uint voxelId(uint particleCount, vec3 pos) {
  vec3 c = pos - gridOrigin;
  if (c.x < 0 || c.x > gridLength.x || c.y < 0 || c.y > gridLength.y || c.z < 0 || c.z > gridLength.z)
    return cellsPerAxis.x * cellsPerAxis.y * cellsPerAxis.z;
  uint xCell = cellId(cellsPerAxis.x, gridLength.x, c.x);
  uint yCell = cellId(cellsPerAxis.y, gridLength.y, c.y);
  uint zCell = cellId(cellsPerAxis.z, gridLength.z, c.z);
  uint vox = xCell + cellsPerAxis.x * (yCell + cellsPerAxis.y * zCell);
  return vox;
}

///
vec3 bbNormal(vec3 pos) {
  vec3 absPos = abs(pos);
  float x = (absPos.x > absPos.y && absPos.x > absPos.z) ? 1.0 : 0.0;
  float y = (absPos.y > absPos.x && absPos.y > absPos.z) ? 1.0 : 0.0;
  float z = (absPos.z > absPos.x && absPos.z > absPos.y) ? 1.0 : 0.0;
  return normalize(vec3(pos.x * x, pos.y * y, pos.z * z));
}

///
vec3 weightPress(float re, vec3 r) {
  return (45 * pow(re - length(r), 3) * r) / (M_PI * pow(re, 6) * length(r));
}

float weightVis(float re, vec3 r) {
  return (re - length(r)) / (M_PI * pow(re, 6));
}

///
float pressure(float d_i) {
  float p_0 = 0.0; // rest pressure
  float d_0 = 10000.0; // rest density
  return p_0 + k * (d_i - d_0);
}

vec3 wallForce(float mass, vec3 pos, float dt) {
  vec3 global = (pos - gridOrigin - gridLength * 0.5) / gridLength;
  float wallDist = 0.5 - max(0.000001, max(abs(global.x), max(abs(global.y), abs(global.z))));
  if (wallDist > restDist)
    return vec3(0.0);
  vec3 wallNormal = -1.0 * bbNormal(global);
  return (mass * (restDist - wallDist) * wallNormal) / (dt * dt);
}

vec3 pressureForce(float mass, vec3 r, float piDen, float pjDen) {
  if (length(r) == 0.0)
    return vec3(0.0);
  float pi = pressure(piDen);
  float pj = pressure(pjDen);
  vec3 wPress = weightPress(re, r);
  return -1.0 * (mass * (pi + pj) * wPress) / (2 * pjDen);
}

vec3 viscosityForce() {
  // TODO
  return vec3(0.0);
}

///
vec3 momentumConservation(float density, vec3 pressure,
  vec3 oldVelocity, float visCoeff, vec3 gravity) {
  // Calculates the velocity.
  vec3 dUdt = (1.0/density) * /*GRADIENT?*/ pressure + visCoeff * /*LAPLACE?*/ oldVelocity + gravity;
  return dUdt;
}

///
void main() {
  vec3 voxelSize = gridLength / cellsPerAxis;
  uint particleCount = mappings.length() / 2;
  uint particlesPerGroup = particleCount / int(gl_NumWorkGroups.x);
  uint startParticle = int(gl_WorkGroupID.x) * particlesPerGroup;
  uint endParticle = startParticle + particlesPerGroup;
  for (uint p = startParticle; p < endParticle; ++p) {
    vec3 pos = vec3(position1[p * 6 + 0], position1[p * 6 + 1], position1[p * 6 + 2]);
    vec3 oldVelocity = vec3(velocity1[p * 3 + 0], velocity1[p * 3 + 1], velocity1[p * 3 + 2]);
    uint vId = voxelId(particleCount, pos);
    float piDen = density2[p];

    vec3 pressure = vec3(0.0);
    for (int x = -1; x <= 1; ++x) {
      for (int y = -1; y <= 1; ++y) {
        for (int z = -1; z <= 1; ++z) {
          vec3 newPos = pos + voxelSize * vec3(x, y, z);
          uint otherVoxelId = voxelId(particleCount, newPos);
          if (otherVoxelId >= cellsPerAxis.x * cellsPerAxis.y * cellsPerAxis.z)
            continue;
          uint otherParticleIndex = indices[otherVoxelId * 2 + 0];
          uint otherParticleSize = indices[otherVoxelId * 2 + 1];
          if (otherParticleSize == 0)
            continue;

          for (uint c = 0; c < otherParticleSize; ++c) {
            uint pjId = mappings[otherParticleIndex * 2 + c * 2];
            vec3 pjPos = vec3(position1[pjId * 6 + 0], position1[pjId * 6 + 1],
              position1[pjId * 6 + 2]);

            vec3 r = pjPos - pos;
            if (length(r) >= re)
              continue;

            float pjDen = density2[pjId];
            // TODO
            pressure += 10* pressureForce(mass, r, piDen, pjDen);
            pressure += viscosityForce();
          }
        }
      }
    }

    // TODO
    //pressure += 100*wallForce(mass, pos, dt);

    vec3 momentumTest = momentumConservation(piDen, pressure, oldVelocity, visCoeff, gravity) * dt;
    velocity2[p * 3 + 0] = momentumTest.x;
    velocity2[p * 3 + 1] = momentumTest.y;
    velocity2[p * 3 + 2] = momentumTest.z;
  }
}
