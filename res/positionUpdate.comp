#version 430 core

/// Pipeline stage 4.
/// This shader calculates the new position from the
/// old position using the new velocity and an explicit
/// Euler integration.
///   Input: Position (1), Velocity (2)
///   Output: Position (2)

layout (location = 0) uniform float dt;

layout (local_size_x = 128) in;

layout (std430, binding = 0) buffer positionBuf1 { float position1[]; };
layout (std430, binding = 1) buffer velocityBuf2 { float velocity2[]; };
layout (std430, binding = 2) buffer positionBuf2 { float position2[]; };

void integrate(uint particle, float dt) {
  uvec3 posIndex = uvec3(particle * 6 + 0, particle * 6 + 1, particle * 6 + 2);
  uvec3 veloIndex = uvec3(particle * 3 + 0, particle * 3 + 1, particle * 3 + 2);
  vec3 oldPos = vec3(position1[posIndex.x], position1[posIndex.y], position1[posIndex.z]);
  vec3 newVelo = vec3(velocity2[veloIndex.x], velocity2[veloIndex.y], velocity2[veloIndex.z]);
  vec3 newPos = oldPos + newVelo * dt;
  position2[posIndex.x] = max(-0.5, min(newPos.x, 0.5));
  position2[posIndex.y] = max(-0.5, min(newPos.y, 0.5));
  position2[posIndex.z] = max(-0.5, min(newPos.z, 0.5));
}

void main() {
  uint particleCount = velocity2.length() / 3;
  uint p = gl_GlobalInvocationID.x;
  if (p >= particleCount)
    return;
  integrate(p, dt);
}
