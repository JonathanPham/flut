#version 430 core

/// Pipeline stage 4.
/// This shader calculates the new position from the
/// old position using the new velocity and an explicit
/// Euler integration.
///   Input: Position (1), Velocity (2)
///   Output: Position (2)

layout (location = 0) uniform float dt;

layout (local_size_x = 128) in;

layout (std430, binding = 0) buffer positionBuf1 { float position1[]; };
layout (std430, binding = 1) buffer velocityBuf2 { float velocity2[]; };
layout (std430, binding = 2) buffer positionBuf2 { float position2[]; };

void integrate(int particle, float dt) {
  uvec3 posIndex = uvec3(particle * 6 + 0, particle * 6 + 1, particle * 6 + 2);
  uvec3 veloIndex = uvec3(particle * 3 + 0, particle * 3 + 1, particle * 3 + 2);
  vec3 oldPos = vec3(position1[posIndex.x], position1[posIndex.y], position1[posIndex.z]);
  vec3 newVelo = vec3(velocity2[veloIndex.x], velocity2[veloIndex.y], velocity2[veloIndex.z]);
  vec3 newPos = oldPos + newVelo * dt;
  position2[posIndex.x] = max(-0.5, min(newPos.x, 0.5));
  position2[posIndex.y] = max(-0.5, min(newPos.y, 0.5));
  position2[posIndex.z] = max(-0.5, min(newPos.z, 0.5));
}

void main() {
  int particlesPerGroup = (position1.length() / 6) / int(gl_NumWorkGroups.x);
  int startParticle = int(gl_WorkGroupID.x) * particlesPerGroup;
  int endParticle = startParticle + particlesPerGroup;
  for (int p = startParticle; p < endParticle; ++p) {
    integrate(p, dt);
  }
}
